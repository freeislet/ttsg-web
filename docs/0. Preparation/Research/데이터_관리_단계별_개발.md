# 데이터 관리 단계별 개발 리서치

## 개요
AI 채팅 앱의 데이터 관리를 단계적으로 개발하는 전략에 대한 조사 결과입니다. 로컬 스토리지에서 시작하여 서버 저장, 동기화 기능까지 점진적으로 확장하는 방안을 다룹니다.

## 1. 개발 단계별 전략

### 1.1 Phase 1: 로컬 스토리지 기반 (MVP)
**목표**: 빠른 프로토타입 개발 및 사용자 피드백 수집

**구현 범위:**
- 채팅 히스토리 로컬 저장
- 사용자 설정 로컬 저장
- 구글 소셜 로그인 (계정 정보만 로컬 저장)
- 세션 관리

**기술 스택:**
```typescript
// 로컬 스토리지 관리
interface LocalStorageManager {
  // 채팅 데이터
  saveChatSession(session: ChatSession): void;
  getChatSessions(): ChatSession[];
  deleteChatSession(sessionId: string): void;
  
  // 사용자 설정
  saveUserSettings(settings: UserSettings): void;
  getUserSettings(): UserSettings;
  
  // 사용자 계정 정보
  saveUserProfile(profile: UserProfile): void;
  getUserProfile(): UserProfile | null;
}
```

### 1.2 Phase 2: 서버 저장 기능 추가
**목표**: 데이터 영속성 및 다중 기기 지원

**구현 범위:**
- Cloudflare D1 데이터베이스 연동
- 사용자 계정 서버 관리
- 채팅 히스토리 서버 저장
- 설정 동기화

**데이터베이스 스키마:**
```sql
-- 사용자 테이블
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  google_id TEXT UNIQUE NOT NULL,
  email TEXT NOT NULL,
  name TEXT NOT NULL,
  avatar_url TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- 채팅 세션 테이블
CREATE TABLE chat_sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  title TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users (id)
);

-- 채팅 메시지 테이블
CREATE TABLE chat_messages (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
  content TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  metadata TEXT, -- JSON 형태
  FOREIGN KEY (session_id) REFERENCES chat_sessions (id)
);

-- 사용자 설정 테이블
CREATE TABLE user_settings (
  user_id TEXT PRIMARY KEY,
  theme TEXT DEFAULT 'auto',
  temperature REAL DEFAULT 0.7,
  max_tokens INTEGER DEFAULT 1000,
  system_prompt TEXT,
  auto_save BOOLEAN DEFAULT true,
  settings_json TEXT, -- 추가 설정들
  FOREIGN KEY (user_id) REFERENCES users (id)
);
```

### 1.3 Phase 3: 데이터 동기화 (선택사항)
**목표**: 기존 로컬 데이터를 서버로 마이그레이션

**구현 범위:**
- 로컬-서버 데이터 동기화
- 충돌 해결 메커니즘
- 마이그레이션 UI

## 2. 구글 소셜 로그인 구현

### 2.1 Remix + Cloudflare Workers 환경에서의 구현

**필요한 패키지:**
```json
{
  "dependencies": {
    "@remix-run/cloudflare": "^2.0.0",
    "remix-auth": "^3.6.0",
    "remix-auth-google": "^2.0.0"
  }
}
```

**환경 변수 설정:**
```bash
# .env
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
SESSION_SECRET=your_session_secret
```

**인증 설정 예시:**
```typescript
// app/services/auth.server.ts
import { Authenticator } from "remix-auth";
import { GoogleStrategy } from "remix-auth-google";
import { sessionStorage } from "~/services/session.server";

export const authenticator = new Authenticator<User>(sessionStorage);

authenticator.use(
  new GoogleStrategy(
    {
      clientID: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      callbackURL: "https://ai-chat.ttsg.space/auth/google/callback",
    },
    async ({ profile }) => {
      // Phase 1: 로컬 스토리지에만 저장
      return {
        id: profile.id,
        email: profile.emails[0].value,
        name: profile.displayName,
        avatar: profile.photos[0].value,
      };
    }
  )
);
```

### 2.2 Phase별 사용자 데이터 처리

**Phase 1 - 로컬 저장:**
```typescript
// 클라이언트 사이드
const handleGoogleLogin = async (userProfile: UserProfile) => {
  // 로컬 스토리지에 사용자 정보 저장
  localStorage.setItem('user_profile', JSON.stringify(userProfile));
  
  // 기존 로컬 데이터와 연결
  const existingData = getLocalChatData();
  if (existingData) {
    // 사용자 ID와 연결
    linkDataToUser(userProfile.id, existingData);
  }
};
```

**Phase 2 - 서버 저장:**
```typescript
// 서버 사이드
export const createOrUpdateUser = async (
  db: D1Database, 
  profile: GoogleProfile
): Promise<User> => {
  const existingUser = await db
    .prepare("SELECT * FROM users WHERE google_id = ?")
    .bind(profile.id)
    .first();

  if (existingUser) {
    // 기존 사용자 업데이트
    await db
      .prepare(`
        UPDATE users 
        SET name = ?, avatar_url = ?, updated_at = ?
        WHERE google_id = ?
      `)
      .bind(profile.displayName, profile.photos[0].value, Date.now(), profile.id)
      .run();
    
    return existingUser as User;
  } else {
    // 새 사용자 생성
    const userId = crypto.randomUUID();
    await db
      .prepare(`
        INSERT INTO users (id, google_id, email, name, avatar_url, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `)
      .bind(
        userId,
        profile.id,
        profile.emails[0].value,
        profile.displayName,
        profile.photos[0].value,
        Date.now(),
        Date.now()
      )
      .run();
    
    return { id: userId, google_id: profile.id, ...profile };
  }
};
```

## 3. 데이터 동기화 전략

### 3.1 동기화 패턴

**1. 단방향 마이그레이션 (권장)**
```typescript
interface MigrationService {
  // 로컬 데이터를 서버로 일회성 마이그레이션
  migrateLocalDataToServer(userId: string): Promise<MigrationResult>;
  
  // 마이그레이션 후 로컬 데이터 정리
  cleanupLocalData(): void;
}

const migrationService: MigrationService = {
  async migrateLocalDataToServer(userId: string) {
    const localSessions = getLocalChatSessions();
    const localSettings = getLocalUserSettings();
    
    const results = {
      sessions: 0,
      messages: 0,
      settings: false,
      errors: [] as string[]
    };
    
    try {
      // 채팅 세션 마이그레이션
      for (const session of localSessions) {
        await createChatSession(userId, session);
        results.sessions++;
        
        for (const message of session.messages) {
          await createChatMessage(session.id, message);
          results.messages++;
        }
      }
      
      // 설정 마이그레이션
      if (localSettings) {
        await saveUserSettings(userId, localSettings);
        results.settings = true;
      }
      
      return results;
    } catch (error) {
      results.errors.push(error.message);
      return results;
    }
  },
  
  cleanupLocalData() {
    localStorage.removeItem('chat_sessions');
    localStorage.removeItem('user_settings');
    localStorage.setItem('migration_completed', 'true');
  }
};
```

**2. 양방향 동기화 (복잡함, 선택사항)**
```typescript
interface SyncService {
  syncToServer(): Promise<void>;
  syncFromServer(): Promise<void>;
  resolveConflicts(conflicts: DataConflict[]): Promise<void>;
}

// 충돌 해결 전략
enum ConflictResolution {
  SERVER_WINS = 'server_wins',
  CLIENT_WINS = 'client_wins',
  MERGE = 'merge',
  ASK_USER = 'ask_user'
}
```

### 3.2 마이그레이션 UI 구현

```typescript
// 마이그레이션 컴포넌트
const DataMigrationModal = () => {
  const [migrationStatus, setMigrationStatus] = useState<'idle' | 'migrating' | 'completed' | 'error'>('idle');
  const [migrationResults, setMigrationResults] = useState<MigrationResult | null>(null);
  
  const handleMigration = async () => {
    setMigrationStatus('migrating');
    
    try {
      const results = await migrationService.migrateLocalDataToServer(user.id);
      setMigrationResults(results);
      setMigrationStatus('completed');
      
      // 성공 시 로컬 데이터 정리
      if (results.errors.length === 0) {
        migrationService.cleanupLocalData();
      }
    } catch (error) {
      setMigrationStatus('error');
    }
  };
  
  return (
    <div className="migration-modal">
      <h3>로컬 데이터를 서버로 동기화</h3>
      <p>기존에 저장된 채팅 기록과 설정을 서버로 이동하시겠습니까?</p>
      
      {migrationStatus === 'idle' && (
        <div>
          <button onClick={handleMigration}>동기화 시작</button>
          <button onClick={() => setShowModal(false)}>나중에</button>
        </div>
      )}
      
      {migrationStatus === 'migrating' && (
        <div>동기화 중...</div>
      )}
      
      {migrationStatus === 'completed' && migrationResults && (
        <div>
          <h4>동기화 완료</h4>
          <p>채팅 세션: {migrationResults.sessions}개</p>
          <p>메시지: {migrationResults.messages}개</p>
          <p>설정: {migrationResults.settings ? '완료' : '없음'}</p>
          {migrationResults.errors.length > 0 && (
            <div>
              <h5>오류:</h5>
              <ul>
                {migrationResults.errors.map((error, i) => (
                  <li key={i}>{error}</li>
                ))}
              </ul>
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

## 4. 구현 우선순위

### 4.1 Phase 1 (2주) - 로컬 스토리지 기반
- [ ] 로컬 스토리지 매니저 구현
- [ ] 구글 소셜 로그인 (로컬 저장)
- [ ] 채팅 히스토리 로컬 관리
- [ ] 사용자 설정 로컬 관리

### 4.2 Phase 2 (2주) - 서버 저장 기능
- [ ] D1 데이터베이스 스키마 설계
- [ ] 사용자 계정 서버 관리
- [ ] 채팅 데이터 서버 저장
- [ ] 설정 동기화

### 4.3 Phase 3 (1주) - 데이터 마이그레이션 (선택사항)
- [ ] 마이그레이션 서비스 구현
- [ ] 마이그레이션 UI 구현
- [ ] 충돌 해결 메커니즘

## 5. 보안 고려사항

### 5.1 로컬 스토리지 보안
- 민감한 정보는 로컬에 저장하지 않음
- 사용자 토큰은 httpOnly 쿠키 사용
- 로컬 데이터 암호화 (선택사항)

### 5.2 서버 보안
- JWT 토큰 기반 인증
- API 엔드포인트 권한 검증
- 사용자별 데이터 격리

## 6. 성능 최적화

### 6.1 로컬 스토리지 최적화
- 대용량 데이터 청킹
- 지연 로딩
- 압축 저장

### 6.2 서버 동기화 최적화
- 배치 업로드
- 델타 동기화
- 백그라운드 동기화

## 7. 결론

단계별 개발 접근법을 통해 빠른 MVP 출시와 점진적 기능 확장이 가능합니다. 로컬 스토리지로 시작하여 사용자 피드백을 받은 후 서버 기능을 추가하는 것이 리스크를 최소화하면서 개발 속도를 높일 수 있는 최적의 전략입니다.

---
*작성일: 2025-09-06*
*작성자: Windsurf AI*

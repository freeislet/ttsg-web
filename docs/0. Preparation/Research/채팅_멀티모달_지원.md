# ì±„íŒ… ë©€í‹°ëª¨ë‹¬ ì§€ì› ë¦¬ì„œì¹˜

## ê°œìš”
Gemini APIë¥¼ í™œìš©í•œ AI ì±„íŒ… ì•±ì—ì„œ í…ìŠ¤íŠ¸ë¿ë§Œ ì•„ë‹ˆë¼ ì´ë¯¸ì§€, ì˜¤ë””ì˜¤, ë¹„ë””ì˜¤, ë¬¸ì„œ ë“± ë‹¤ì–‘í•œ ë¯¸ë””ì–´ íƒ€ì…ì„ ì§€ì›í•˜ëŠ” ë©€í‹°ëª¨ë‹¬ ì±„íŒ… ê¸°ëŠ¥ì— ëŒ€í•œ ì¡°ì‚¬ ê²°ê³¼ì…ë‹ˆë‹¤.

## 1. Gemini API ë©€í‹°ëª¨ë‹¬ ì§€ì› í˜„í™©

### 1.1 ì§€ì› ë¯¸ë””ì–´ íƒ€ì…
**ì´ë¯¸ì§€:**
- JPEG, PNG, WebP, HEIC, HEIF
- ìµœëŒ€ íŒŒì¼ í¬ê¸°: 20MB
- ì¸ë¼ì¸ ë°ì´í„° ë˜ëŠ” Files API ì—…ë¡œë“œ ì§€ì›

**ì˜¤ë””ì˜¤:**
- WAV, MP3, AIFF, AAC, OGG, FLAC
- ìµœëŒ€ íŒŒì¼ í¬ê¸°: 2GB
- Files APIë¥¼ í†µí•œ ì—…ë¡œë“œ í•„ìš”

**ë¹„ë””ì˜¤:**
- MP4, MOV, AVI, FLV, MPG, MPEG, MPEGPS, WMV
- ìµœëŒ€ íŒŒì¼ í¬ê¸°: 2GB
- ìµœëŒ€ ê¸¸ì´: 2ì‹œê°„
- Files APIë¥¼ í†µí•œ ì—…ë¡œë“œ í•„ìš”

**ë¬¸ì„œ:**
- PDF, TXT, HTML, CSS, JavaScript, Python ë“±
- ìµœëŒ€ íŒŒì¼ í¬ê¸°: 20MB
- Files APIë¥¼ í†µí•œ ì—…ë¡œë“œ í•„ìš”

### 1.2 Files API ì œí•œì‚¬í•­
- **ì €ì¥ ìš©ëŸ‰**: í”„ë¡œì íŠ¸ë‹¹ ìµœëŒ€ 20GB
- **íŒŒì¼ ë³´ì¡´**: ì—…ë¡œë“œ í›„ 48ì‹œê°„
- **ë™ì‹œ ì—…ë¡œë“œ**: ì œí•œ ì—†ìŒ (API í• ë‹¹ëŸ‰ ë‚´ì—ì„œ)
- **ë¹„ìš©**: ë¬´ë£Œ (Gemini API ì‚¬ìš© ê°€ëŠ¥ ì§€ì—­ì—ì„œ)

## 2. ê¸°ìˆ  êµ¬í˜„ ë°©ì•ˆ

### 2.1 íŒŒì¼ ì—…ë¡œë“œ ì•„í‚¤í…ì²˜

```
[í´ë¼ì´ì–¸íŠ¸] â†’ [Remix Route] â†’ [Files API] â†’ [Gemini API]
     â†“              â†“              â†“
[íŒŒì¼ ì„ íƒ]    [íŒŒì¼ ê²€ì¦]    [íŒŒì¼ ì €ì¥]
     â†“              â†“              â†“
[ë¯¸ë¦¬ë³´ê¸°]    [ì§„í–‰ë¥  í‘œì‹œ]   [ë©”íƒ€ë°ì´í„°]
```

### 2.2 Remixì—ì„œì˜ êµ¬í˜„

**íŒŒì¼ ì—…ë¡œë“œ Route:**
```typescript
// app/routes/api.upload.ts
import { json, type ActionFunctionArgs } from "@remix-run/cloudflare";
import { GoogleGenAI } from "@google/genai";

export async function action({ request, context }: ActionFunctionArgs) {
  const formData = await request.formData();
  const file = formData.get("file") as File;
  
  if (!file) {
    return json({ error: "íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤." }, { status: 400 });
  }
  
  // íŒŒì¼ í¬ê¸° ë° íƒ€ì… ê²€ì¦
  const maxSize = getMaxFileSize(file.type);
  if (file.size > maxSize) {
    return json({ error: "íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤." }, { status: 400 });
  }
  
  if (!isSupportedFileType(file.type)) {
    return json({ error: "ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤." }, { status: 400 });
  }
  
  try {
    const ai = new GoogleGenAI({ apiKey: context.env.GEMINI_API_KEY });
    
    // Files APIë¥¼ í†µí•œ ì—…ë¡œë“œ
    const uploadedFile = await ai.files.upload({
      file: file,
      config: {
        mimeType: file.type,
        displayName: file.name
      }
    });
    
    return json({
      fileId: uploadedFile.name,
      uri: uploadedFile.uri,
      mimeType: uploadedFile.mimeType,
      displayName: uploadedFile.displayName,
      sizeBytes: uploadedFile.sizeBytes
    });
    
  } catch (error) {
    return json({ error: "íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨" }, { status: 500 });
  }
}

// íŒŒì¼ íƒ€ì…ë³„ ìµœëŒ€ í¬ê¸° ì„¤ì •
function getMaxFileSize(mimeType: string): number {
  if (mimeType.startsWith('image/')) return 20 * 1024 * 1024; // 20MB
  if (mimeType.startsWith('audio/')) return 2 * 1024 * 1024 * 1024; // 2GB
  if (mimeType.startsWith('video/')) return 2 * 1024 * 1024 * 1024; // 2GB
  if (mimeType === 'application/pdf') return 20 * 1024 * 1024; // 20MB
  return 20 * 1024 * 1024; // ê¸°ë³¸ 20MB
}

// ì§€ì› íŒŒì¼ íƒ€ì… ê²€ì¦
function isSupportedFileType(mimeType: string): boolean {
  const supportedTypes = [
    // ì´ë¯¸ì§€
    'image/jpeg', 'image/png', 'image/webp', 'image/heic', 'image/heif',
    // ì˜¤ë””ì˜¤
    'audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/aiff', 'audio/aac', 'audio/ogg', 'audio/flac',
    // ë¹„ë””ì˜¤
    'video/mp4', 'video/mov', 'video/avi', 'video/x-flv', 'video/mpg', 'video/mpeg', 'video/x-ms-wmv',
    // ë¬¸ì„œ
    'application/pdf', 'text/plain', 'text/html', 'text/css', 'application/javascript', 'text/x-python'
  ];
  
  return supportedTypes.includes(mimeType);
}
```

**ì±„íŒ… API ë©€í‹°ëª¨ë‹¬ ì§€ì›:**
```typescript
// app/routes/api.chat.ts
export async function action({ request, context }: ActionFunctionArgs) {
  const { message, files, history } = await request.json();
  
  const ai = new GoogleGenAI({ apiKey: context.env.GEMINI_API_KEY });
  
  // ë©€í‹°ëª¨ë‹¬ ì½˜í…ì¸  êµ¬ì„±
  const contents = [];
  
  // í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ì¶”ê°€
  if (message) {
    contents.push({ text: message });
  }
  
  // íŒŒì¼ë“¤ ì¶”ê°€
  if (files && files.length > 0) {
    for (const file of files) {
      contents.push({
        fileData: {
          mimeType: file.mimeType,
          fileUri: file.uri
        }
      });
    }
  }
  
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [{ parts: contents }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 1000
      }
    });
    
    return json({
      message: response.text,
      timestamp: Date.now()
    });
    
  } catch (error) {
    return json({ error: "AI ì‘ë‹µ ìƒì„± ì‹¤íŒ¨" }, { status: 500 });
  }
}
```

### 2.3 í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ êµ¬í˜„

**íŒŒì¼ ì—…ë¡œë“œ ì»´í¬ë„ŒíŠ¸:**
```typescript
// app/components/FileUpload.tsx
import { useState, useRef } from "react";
import { useFetcher } from "@remix-run/react";

interface UploadedFile {
  fileId: string;
  uri: string;
  mimeType: string;
  displayName: string;
  sizeBytes: number;
}

export const FileUpload = ({ onFileUploaded }: { onFileUploaded: (file: UploadedFile) => void }) => {
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const fetcher = useFetcher();
  
  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    
    setUploading(true);
    setUploadProgress(0);
    
    const formData = new FormData();
    formData.append("file", file);
    
    try {
      // XMLHttpRequestë¥¼ ì‚¬ìš©í•˜ì—¬ ì—…ë¡œë“œ ì§„í–‰ë¥  ì¶”ì 
      const xhr = new XMLHttpRequest();
      
      xhr.upload.onprogress = (event) => {
        if (event.lengthComputable) {
          const progress = (event.loaded / event.total) * 100;
          setUploadProgress(progress);
        }
      };
      
      xhr.onload = () => {
        if (xhr.status === 200) {
          const result = JSON.parse(xhr.responseText);
          onFileUploaded(result);
        }
        setUploading(false);
      };
      
      xhr.onerror = () => {
        setUploading(false);
        alert("íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨");
      };
      
      xhr.open("POST", "/api/upload");
      xhr.send(formData);
      
    } catch (error) {
      setUploading(false);
      alert("íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨");
    }
  };
  
  return (
    <div className="file-upload">
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*,audio/*,video/*,.pdf,.txt"
        onChange={handleFileSelect}
        style={{ display: 'none' }}
      />
      
      <button
        onClick={() => fileInputRef.current?.click()}
        disabled={uploading}
        className="upload-button"
      >
        {uploading ? `ì—…ë¡œë“œ ì¤‘... ${uploadProgress.toFixed(0)}%` : "íŒŒì¼ ì²¨ë¶€"}
      </button>
    </div>
  );
};
```

**ë©€í‹°ëª¨ë‹¬ ë©”ì‹œì§€ ì»´í¬ë„ŒíŠ¸:**
```typescript
// app/components/MultimodalMessage.tsx
interface MessageFile {
  fileId: string;
  uri: string;
  mimeType: string;
  displayName: string;
}

interface MultimodalMessageProps {
  text?: string;
  files?: MessageFile[];
  role: 'user' | 'assistant';
}

export const MultimodalMessage = ({ text, files, role }: MultimodalMessageProps) => {
  const renderFile = (file: MessageFile) => {
    if (file.mimeType.startsWith('image/')) {
      return (
        <img
          src={`/api/file-proxy/${file.fileId}`}
          alt={file.displayName}
          className="max-w-xs rounded-lg"
        />
      );
    }
    
    if (file.mimeType.startsWith('audio/')) {
      return (
        <audio controls className="w-full max-w-xs">
          <source src={`/api/file-proxy/${file.fileId}`} type={file.mimeType} />
        </audio>
      );
    }
    
    if (file.mimeType.startsWith('video/')) {
      return (
        <video controls className="max-w-xs rounded-lg">
          <source src={`/api/file-proxy/${file.fileId}`} type={file.mimeType} />
        </video>
      );
    }
    
    // ë¬¸ì„œ íŒŒì¼
    return (
      <div className="file-attachment">
        <span className="file-icon">ğŸ“„</span>
        <span className="file-name">{file.displayName}</span>
      </div>
    );
  };
  
  return (
    <div className={`message ${role}`}>
      {files && files.length > 0 && (
        <div className="message-files">
          {files.map((file) => (
            <div key={file.fileId} className="file-preview">
              {renderFile(file)}
            </div>
          ))}
        </div>
      )}
      
      {text && (
        <div className="message-text">
          {text}
        </div>
      )}
    </div>
  );
};
```

## 3. ì‚¬ìš©ì ê²½í—˜ ì„¤ê³„

### 3.1 íŒŒì¼ ì—…ë¡œë“œ í”Œë¡œìš°
1. **íŒŒì¼ ì„ íƒ**: ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë˜ëŠ” íŒŒì¼ ì„ íƒ ë²„íŠ¼
2. **íŒŒì¼ ê²€ì¦**: í¬ê¸°, í˜•ì‹ ê²€ì¦ ë° ì‚¬ìš©ì í”¼ë“œë°±
3. **ì—…ë¡œë“œ ì§„í–‰**: ì§„í–‰ë¥  í‘œì‹œ ë° ì·¨ì†Œ ê¸°ëŠ¥
4. **ë¯¸ë¦¬ë³´ê¸°**: ì—…ë¡œë“œëœ íŒŒì¼ì˜ ì¸ë„¤ì¼ ë˜ëŠ” ì •ë³´ í‘œì‹œ
5. **ë©”ì‹œì§€ ì „ì†¡**: í…ìŠ¤íŠ¸ì™€ í•¨ê»˜ ë˜ëŠ” íŒŒì¼ë§Œ ì „ì†¡

### 3.2 UI/UX ê³ ë ¤ì‚¬í•­

**íŒŒì¼ ë¯¸ë¦¬ë³´ê¸°:**
```typescript
// íŒŒì¼ íƒ€ì…ë³„ ë¯¸ë¦¬ë³´ê¸° ì»´í¬ë„ŒíŠ¸
const FilePreview = ({ file, onRemove }: { file: UploadedFile, onRemove: () => void }) => {
  const getPreview = () => {
    if (file.mimeType.startsWith('image/')) {
      return <img src={file.uri} alt={file.displayName} className="preview-image" />;
    }
    
    if (file.mimeType.startsWith('audio/')) {
      return (
        <div className="audio-preview">
          <span className="audio-icon">ğŸµ</span>
          <span className="file-name">{file.displayName}</span>
        </div>
      );
    }
    
    if (file.mimeType.startsWith('video/')) {
      return (
        <div className="video-preview">
          <span className="video-icon">ğŸ¬</span>
          <span className="file-name">{file.displayName}</span>
        </div>
      );
    }
    
    return (
      <div className="document-preview">
        <span className="document-icon">ğŸ“„</span>
        <span className="file-name">{file.displayName}</span>
      </div>
    );
  };
  
  return (
    <div className="file-preview-container">
      {getPreview()}
      <button onClick={onRemove} className="remove-file-btn">Ã—</button>
    </div>
  );
};
```

**ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì§€ì›:**
```typescript
const DragDropUpload = ({ onFilesSelected }: { onFilesSelected: (files: FileList) => void }) => {
  const [isDragOver, setIsDragOver] = useState(false);
  
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  };
  
  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
  };
  
  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      onFilesSelected(files);
    }
  };
  
  return (
    <div
      className={`drag-drop-area ${isDragOver ? 'drag-over' : ''}`}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <p>íŒŒì¼ì„ ì—¬ê¸°ì— ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</p>
    </div>
  );
};
```

## 4. ì„±ëŠ¥ ìµœì í™”

### 4.1 íŒŒì¼ ì²˜ë¦¬ ìµœì í™”
- **ì´ë¯¸ì§€ ì••ì¶•**: í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì—…ë¡œë“œ ì „ ì••ì¶•
- **ì²­í¬ ì—…ë¡œë“œ**: ëŒ€ìš©ëŸ‰ íŒŒì¼ì˜ ë¶„í•  ì—…ë¡œë“œ
- **ë³‘ë ¬ ì²˜ë¦¬**: ì—¬ëŸ¬ íŒŒì¼ ë™ì‹œ ì—…ë¡œë“œ
- **ìºì‹±**: ì—…ë¡œë“œëœ íŒŒì¼ ë©”íƒ€ë°ì´í„° ìºì‹±

### 4.2 ë©”ëª¨ë¦¬ ê´€ë¦¬
```typescript
// íŒŒì¼ ì—…ë¡œë“œ í›„ ë©”ëª¨ë¦¬ ì •ë¦¬
const cleanupFileReferences = (fileId: string) => {
  // 48ì‹œê°„ í›„ ìë™ ì‚­ì œë˜ë¯€ë¡œ ë¡œì»¬ ì°¸ì¡°ë§Œ ì •ë¦¬
  localStorage.removeItem(`file_${fileId}`);
};

// ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ì‹œ ìŠ¤íŠ¸ë¦¬ë°
const processLargeFile = async (file: File) => {
  const chunkSize = 1024 * 1024; // 1MB ì²­í¬
  const chunks = Math.ceil(file.size / chunkSize);
  
  for (let i = 0; i < chunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);
    
    await uploadChunk(chunk, i, chunks);
  }
};
```

## 5. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 5.1 íŒŒì¼ ê²€ì¦
```typescript
// íŒŒì¼ ë‚´ìš© ê¸°ë°˜ ê²€ì¦
const validateFileContent = async (file: File): Promise<boolean> => {
  // íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ ê²€ì¦
  const buffer = await file.arrayBuffer();
  const uint8Array = new Uint8Array(buffer);
  
  // JPEG íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ í™•ì¸ ì˜ˆì‹œ
  if (file.type === 'image/jpeg') {
    return uint8Array[0] === 0xFF && uint8Array[1] === 0xD8;
  }
  
  // ë‹¤ë¥¸ íŒŒì¼ íƒ€ì…ë“¤ë„ ìœ ì‚¬í•˜ê²Œ ê²€ì¦
  return true;
};

// ì•…ì„± íŒŒì¼ ìŠ¤ìº” (ì„ íƒì‚¬í•­)
const scanForMalware = async (fileId: string): Promise<boolean> => {
  // ì™¸ë¶€ ìŠ¤ìº” ì„œë¹„ìŠ¤ ì—°ë™ ë˜ëŠ” ê¸°ë³¸ íŒ¨í„´ ë§¤ì¹­
  return true;
};
```

### 5.2 ì ‘ê·¼ ì œì–´
- ì—…ë¡œë“œëœ íŒŒì¼ì€ ì—…ë¡œë”ë§Œ ì ‘ê·¼ ê°€ëŠ¥
- íŒŒì¼ ê³µìœ  ì‹œ ì„ì‹œ í† í° ì‚¬ìš©
- ë¯¼ê°í•œ ì •ë³´ ìë™ ê°ì§€ ë° ê²½ê³ 

## 6. êµ¬í˜„ ë‹¨ê³„ë³„ ê³„íš

### 6.1 Phase 1: ê¸°ë³¸ ì´ë¯¸ì§€ ì§€ì› (1ì£¼)
- [ ] ì´ë¯¸ì§€ íŒŒì¼ ì—…ë¡œë“œ êµ¬í˜„
- [ ] ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ê¸°ëŠ¥
- [ ] ê¸°ë³¸ íŒŒì¼ ê²€ì¦
- [ ] ì±„íŒ…ì—ì„œ ì´ë¯¸ì§€ í‘œì‹œ

### 6.2 Phase 2: ì˜¤ë””ì˜¤/ë¹„ë””ì˜¤ ì§€ì› (1ì£¼)
- [ ] ì˜¤ë””ì˜¤ íŒŒì¼ ì—…ë¡œë“œ ë° ì¬ìƒ
- [ ] ë¹„ë””ì˜¤ íŒŒì¼ ì—…ë¡œë“œ ë° ì¬ìƒ
- [ ] ëŒ€ìš©ëŸ‰ íŒŒì¼ ì—…ë¡œë“œ ìµœì í™”
- [ ] ì§„í–‰ë¥  í‘œì‹œ

### 6.3 Phase 3: ë¬¸ì„œ ì§€ì› ë° ê³ ê¸‰ ê¸°ëŠ¥ (1ì£¼)
- [ ] PDF, í…ìŠ¤íŠ¸ íŒŒì¼ ì§€ì›
- [ ] ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì¸í„°í˜ì´ìŠ¤
- [ ] íŒŒì¼ ê´€ë¦¬ ê¸°ëŠ¥
- [ ] ì„±ëŠ¥ ìµœì í™”

## 7. ì œí•œì‚¬í•­ ë° ê³ ë ¤ì‚¬í•­

### 7.1 API ì œí•œì‚¬í•­
- íŒŒì¼ ë³´ì¡´ ê¸°ê°„: 48ì‹œê°„
- í”„ë¡œì íŠ¸ë‹¹ ì €ì¥ ìš©ëŸ‰: 20GB
- íŒŒì¼ë‹¹ ìµœëŒ€ í¬ê¸°: 2GB
- ë¹„ë””ì˜¤ ìµœëŒ€ ê¸¸ì´: 2ì‹œê°„

### 7.2 ì‚¬ìš©ì ê²½í—˜ ê³ ë ¤ì‚¬í•­
- íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜
- ë„¤íŠ¸ì›Œí¬ ìƒíƒœì— ë”°ë¥¸ ì—…ë¡œë“œ í’ˆì§ˆ ì¡°ì •
- ëª¨ë°”ì¼ í™˜ê²½ì—ì„œì˜ íŒŒì¼ ì„ íƒ ìµœì í™”
- ì ‘ê·¼ì„± ê³ ë ¤ (ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›)

## 8. ê²°ë¡ 

Gemini APIì˜ ê°•ë ¥í•œ ë©€í‹°ëª¨ë‹¬ ì§€ì›ì„ í™œìš©í•˜ì—¬ í…ìŠ¤íŠ¸, ì´ë¯¸ì§€, ì˜¤ë””ì˜¤, ë¹„ë””ì˜¤, ë¬¸ì„œë¥¼ ëª¨ë‘ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” í¬ê´„ì ì¸ AI ì±„íŒ… ê²½í—˜ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¨ê³„ì  êµ¬í˜„ì„ í†µí•´ ê¸°ë³¸ ê¸°ëŠ¥ë¶€í„° ê³ ê¸‰ ê¸°ëŠ¥ê¹Œì§€ ì ì§„ì ìœ¼ë¡œ í™•ì¥í•˜ëŠ” ê²ƒì´ íš¨ê³¼ì ì…ë‹ˆë‹¤.

---
*ì‘ì„±ì¼: 2025-09-06*
*ì‘ì„±ì: Windsurf AI*

# 채팅 멀티모달 지원 리서치

## 개요
Gemini API를 활용한 AI 채팅 앱에서 텍스트뿐만 아니라 이미지, 오디오, 비디오, 문서 등 다양한 미디어 타입을 지원하는 멀티모달 채팅 기능에 대한 조사 결과입니다.

## 1. Gemini API 멀티모달 지원 현황

### 1.1 지원 미디어 타입
**이미지:**
- JPEG, PNG, WebP, HEIC, HEIF
- 최대 파일 크기: 20MB
- 인라인 데이터 또는 Files API 업로드 지원

**오디오:**
- WAV, MP3, AIFF, AAC, OGG, FLAC
- 최대 파일 크기: 2GB
- Files API를 통한 업로드 필요

**비디오:**
- MP4, MOV, AVI, FLV, MPG, MPEG, MPEGPS, WMV
- 최대 파일 크기: 2GB
- 최대 길이: 2시간
- Files API를 통한 업로드 필요

**문서:**
- PDF, TXT, HTML, CSS, JavaScript, Python 등
- 최대 파일 크기: 20MB
- Files API를 통한 업로드 필요

### 1.2 Files API 제한사항
- **저장 용량**: 프로젝트당 최대 20GB
- **파일 보존**: 업로드 후 48시간
- **동시 업로드**: 제한 없음 (API 할당량 내에서)
- **비용**: 무료 (Gemini API 사용 가능 지역에서)

## 2. 기술 구현 방안

### 2.1 파일 업로드 아키텍처

```
[클라이언트] → [Remix Route] → [Files API] → [Gemini API]
     ↓              ↓              ↓
[파일 선택]    [파일 검증]    [파일 저장]
     ↓              ↓              ↓
[미리보기]    [진행률 표시]   [메타데이터]
```

### 2.2 Remix에서의 구현

**파일 업로드 Route:**
```typescript
// app/routes/api.upload.ts
import { json, type ActionFunctionArgs } from "@remix-run/cloudflare";
import { GoogleGenAI } from "@google/genai";

export async function action({ request, context }: ActionFunctionArgs) {
  const formData = await request.formData();
  const file = formData.get("file") as File;
  
  if (!file) {
    return json({ error: "파일이 없습니다." }, { status: 400 });
  }
  
  // 파일 크기 및 타입 검증
  const maxSize = getMaxFileSize(file.type);
  if (file.size > maxSize) {
    return json({ error: "파일 크기가 너무 큽니다." }, { status: 400 });
  }
  
  if (!isSupportedFileType(file.type)) {
    return json({ error: "지원하지 않는 파일 형식입니다." }, { status: 400 });
  }
  
  try {
    const ai = new GoogleGenAI({ apiKey: context.env.GEMINI_API_KEY });
    
    // Files API를 통한 업로드
    const uploadedFile = await ai.files.upload({
      file: file,
      config: {
        mimeType: file.type,
        displayName: file.name
      }
    });
    
    return json({
      fileId: uploadedFile.name,
      uri: uploadedFile.uri,
      mimeType: uploadedFile.mimeType,
      displayName: uploadedFile.displayName,
      sizeBytes: uploadedFile.sizeBytes
    });
    
  } catch (error) {
    return json({ error: "파일 업로드 실패" }, { status: 500 });
  }
}

// 파일 타입별 최대 크기 설정
function getMaxFileSize(mimeType: string): number {
  if (mimeType.startsWith('image/')) return 20 * 1024 * 1024; // 20MB
  if (mimeType.startsWith('audio/')) return 2 * 1024 * 1024 * 1024; // 2GB
  if (mimeType.startsWith('video/')) return 2 * 1024 * 1024 * 1024; // 2GB
  if (mimeType === 'application/pdf') return 20 * 1024 * 1024; // 20MB
  return 20 * 1024 * 1024; // 기본 20MB
}

// 지원 파일 타입 검증
function isSupportedFileType(mimeType: string): boolean {
  const supportedTypes = [
    // 이미지
    'image/jpeg', 'image/png', 'image/webp', 'image/heic', 'image/heif',
    // 오디오
    'audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/aiff', 'audio/aac', 'audio/ogg', 'audio/flac',
    // 비디오
    'video/mp4', 'video/mov', 'video/avi', 'video/x-flv', 'video/mpg', 'video/mpeg', 'video/x-ms-wmv',
    // 문서
    'application/pdf', 'text/plain', 'text/html', 'text/css', 'application/javascript', 'text/x-python'
  ];
  
  return supportedTypes.includes(mimeType);
}
```

**채팅 API 멀티모달 지원:**
```typescript
// app/routes/api.chat.ts
export async function action({ request, context }: ActionFunctionArgs) {
  const { message, files, history } = await request.json();
  
  const ai = new GoogleGenAI({ apiKey: context.env.GEMINI_API_KEY });
  
  // 멀티모달 콘텐츠 구성
  const contents = [];
  
  // 텍스트 메시지 추가
  if (message) {
    contents.push({ text: message });
  }
  
  // 파일들 추가
  if (files && files.length > 0) {
    for (const file of files) {
      contents.push({
        fileData: {
          mimeType: file.mimeType,
          fileUri: file.uri
        }
      });
    }
  }
  
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [{ parts: contents }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 1000
      }
    });
    
    return json({
      message: response.text,
      timestamp: Date.now()
    });
    
  } catch (error) {
    return json({ error: "AI 응답 생성 실패" }, { status: 500 });
  }
}
```

### 2.3 클라이언트 사이드 구현

**파일 업로드 컴포넌트:**
```typescript
// app/components/FileUpload.tsx
import { useState, useRef } from "react";
import { useFetcher } from "@remix-run/react";

interface UploadedFile {
  fileId: string;
  uri: string;
  mimeType: string;
  displayName: string;
  sizeBytes: number;
}

export const FileUpload = ({ onFileUploaded }: { onFileUploaded: (file: UploadedFile) => void }) => {
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const fetcher = useFetcher();
  
  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    
    setUploading(true);
    setUploadProgress(0);
    
    const formData = new FormData();
    formData.append("file", file);
    
    try {
      // XMLHttpRequest를 사용하여 업로드 진행률 추적
      const xhr = new XMLHttpRequest();
      
      xhr.upload.onprogress = (event) => {
        if (event.lengthComputable) {
          const progress = (event.loaded / event.total) * 100;
          setUploadProgress(progress);
        }
      };
      
      xhr.onload = () => {
        if (xhr.status === 200) {
          const result = JSON.parse(xhr.responseText);
          onFileUploaded(result);
        }
        setUploading(false);
      };
      
      xhr.onerror = () => {
        setUploading(false);
        alert("파일 업로드 실패");
      };
      
      xhr.open("POST", "/api/upload");
      xhr.send(formData);
      
    } catch (error) {
      setUploading(false);
      alert("파일 업로드 실패");
    }
  };
  
  return (
    <div className="file-upload">
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*,audio/*,video/*,.pdf,.txt"
        onChange={handleFileSelect}
        style={{ display: 'none' }}
      />
      
      <button
        onClick={() => fileInputRef.current?.click()}
        disabled={uploading}
        className="upload-button"
      >
        {uploading ? `업로드 중... ${uploadProgress.toFixed(0)}%` : "파일 첨부"}
      </button>
    </div>
  );
};
```

**멀티모달 메시지 컴포넌트:**
```typescript
// app/components/MultimodalMessage.tsx
interface MessageFile {
  fileId: string;
  uri: string;
  mimeType: string;
  displayName: string;
}

interface MultimodalMessageProps {
  text?: string;
  files?: MessageFile[];
  role: 'user' | 'assistant';
}

export const MultimodalMessage = ({ text, files, role }: MultimodalMessageProps) => {
  const renderFile = (file: MessageFile) => {
    if (file.mimeType.startsWith('image/')) {
      return (
        <img
          src={`/api/file-proxy/${file.fileId}`}
          alt={file.displayName}
          className="max-w-xs rounded-lg"
        />
      );
    }
    
    if (file.mimeType.startsWith('audio/')) {
      return (
        <audio controls className="w-full max-w-xs">
          <source src={`/api/file-proxy/${file.fileId}`} type={file.mimeType} />
        </audio>
      );
    }
    
    if (file.mimeType.startsWith('video/')) {
      return (
        <video controls className="max-w-xs rounded-lg">
          <source src={`/api/file-proxy/${file.fileId}`} type={file.mimeType} />
        </video>
      );
    }
    
    // 문서 파일
    return (
      <div className="file-attachment">
        <span className="file-icon">📄</span>
        <span className="file-name">{file.displayName}</span>
      </div>
    );
  };
  
  return (
    <div className={`message ${role}`}>
      {files && files.length > 0 && (
        <div className="message-files">
          {files.map((file) => (
            <div key={file.fileId} className="file-preview">
              {renderFile(file)}
            </div>
          ))}
        </div>
      )}
      
      {text && (
        <div className="message-text">
          {text}
        </div>
      )}
    </div>
  );
};
```

## 3. 사용자 경험 설계

### 3.1 파일 업로드 플로우
1. **파일 선택**: 드래그 앤 드롭 또는 파일 선택 버튼
2. **파일 검증**: 크기, 형식 검증 및 사용자 피드백
3. **업로드 진행**: 진행률 표시 및 취소 기능
4. **미리보기**: 업로드된 파일의 썸네일 또는 정보 표시
5. **메시지 전송**: 텍스트와 함께 또는 파일만 전송

### 3.2 UI/UX 고려사항

**파일 미리보기:**
```typescript
// 파일 타입별 미리보기 컴포넌트
const FilePreview = ({ file, onRemove }: { file: UploadedFile, onRemove: () => void }) => {
  const getPreview = () => {
    if (file.mimeType.startsWith('image/')) {
      return <img src={file.uri} alt={file.displayName} className="preview-image" />;
    }
    
    if (file.mimeType.startsWith('audio/')) {
      return (
        <div className="audio-preview">
          <span className="audio-icon">🎵</span>
          <span className="file-name">{file.displayName}</span>
        </div>
      );
    }
    
    if (file.mimeType.startsWith('video/')) {
      return (
        <div className="video-preview">
          <span className="video-icon">🎬</span>
          <span className="file-name">{file.displayName}</span>
        </div>
      );
    }
    
    return (
      <div className="document-preview">
        <span className="document-icon">📄</span>
        <span className="file-name">{file.displayName}</span>
      </div>
    );
  };
  
  return (
    <div className="file-preview-container">
      {getPreview()}
      <button onClick={onRemove} className="remove-file-btn">×</button>
    </div>
  );
};
```

**드래그 앤 드롭 지원:**
```typescript
const DragDropUpload = ({ onFilesSelected }: { onFilesSelected: (files: FileList) => void }) => {
  const [isDragOver, setIsDragOver] = useState(false);
  
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  };
  
  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
  };
  
  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      onFilesSelected(files);
    }
  };
  
  return (
    <div
      className={`drag-drop-area ${isDragOver ? 'drag-over' : ''}`}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <p>파일을 여기에 드래그하거나 클릭하여 선택하세요</p>
    </div>
  );
};
```

## 4. 성능 최적화

### 4.1 파일 처리 최적화
- **이미지 압축**: 클라이언트에서 업로드 전 압축
- **청크 업로드**: 대용량 파일의 분할 업로드
- **병렬 처리**: 여러 파일 동시 업로드
- **캐싱**: 업로드된 파일 메타데이터 캐싱

### 4.2 메모리 관리
```typescript
// 파일 업로드 후 메모리 정리
const cleanupFileReferences = (fileId: string) => {
  // 48시간 후 자동 삭제되므로 로컬 참조만 정리
  localStorage.removeItem(`file_${fileId}`);
};

// 대용량 파일 처리 시 스트리밍
const processLargeFile = async (file: File) => {
  const chunkSize = 1024 * 1024; // 1MB 청크
  const chunks = Math.ceil(file.size / chunkSize);
  
  for (let i = 0; i < chunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);
    
    await uploadChunk(chunk, i, chunks);
  }
};
```

## 5. 보안 고려사항

### 5.1 파일 검증
```typescript
// 파일 내용 기반 검증
const validateFileContent = async (file: File): Promise<boolean> => {
  // 파일 시그니처 검증
  const buffer = await file.arrayBuffer();
  const uint8Array = new Uint8Array(buffer);
  
  // JPEG 파일 시그니처 확인 예시
  if (file.type === 'image/jpeg') {
    return uint8Array[0] === 0xFF && uint8Array[1] === 0xD8;
  }
  
  // 다른 파일 타입들도 유사하게 검증
  return true;
};

// 악성 파일 스캔 (선택사항)
const scanForMalware = async (fileId: string): Promise<boolean> => {
  // 외부 스캔 서비스 연동 또는 기본 패턴 매칭
  return true;
};
```

### 5.2 접근 제어
- 업로드된 파일은 업로더만 접근 가능
- 파일 공유 시 임시 토큰 사용
- 민감한 정보 자동 감지 및 경고

## 6. 구현 단계별 계획

### 6.1 Phase 1: 기본 이미지 지원 (1주)
- [ ] 이미지 파일 업로드 구현
- [ ] 이미지 미리보기 기능
- [ ] 기본 파일 검증
- [ ] 채팅에서 이미지 표시

### 6.2 Phase 2: 오디오/비디오 지원 (1주)
- [ ] 오디오 파일 업로드 및 재생
- [ ] 비디오 파일 업로드 및 재생
- [ ] 대용량 파일 업로드 최적화
- [ ] 진행률 표시

### 6.3 Phase 3: 문서 지원 및 고급 기능 (1주)
- [ ] PDF, 텍스트 파일 지원
- [ ] 드래그 앤 드롭 인터페이스
- [ ] 파일 관리 기능
- [ ] 성능 최적화

## 7. 제한사항 및 고려사항

### 7.1 API 제한사항
- 파일 보존 기간: 48시간
- 프로젝트당 저장 용량: 20GB
- 파일당 최대 크기: 2GB
- 비디오 최대 길이: 2시간

### 7.2 사용자 경험 고려사항
- 파일 업로드 실패 시 재시도 메커니즘
- 네트워크 상태에 따른 업로드 품질 조정
- 모바일 환경에서의 파일 선택 최적화
- 접근성 고려 (스크린 리더 지원)

## 8. 결론

Gemini API의 강력한 멀티모달 지원을 활용하여 텍스트, 이미지, 오디오, 비디오, 문서를 모두 처리할 수 있는 포괄적인 AI 채팅 경험을 제공할 수 있습니다. 단계적 구현을 통해 기본 기능부터 고급 기능까지 점진적으로 확장하는 것이 효과적입니다.

---
*작성일: 2025-09-06*
*작성자: Windsurf AI*
